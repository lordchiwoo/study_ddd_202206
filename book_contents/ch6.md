# Chapter 6. 응용서비스와 표현영역

## 6.1 표현 영역과 응용 영역
* 응용 영역과 표현 영역은 사용자와 도메인을 연결해주는 매개체
	* 응용 영역은 실제 사용자가 원하는 기능을 실행하기 위해 필요한 입력을 메서드 인자로 받고 실행 결과를 리턴
	* 응용 서비스의 메서드가 요구하는 파라미터 형식 != 표현 영역이 사용자로부터 전달받은 데이터 형식
	* 표현 영역
		* 사용자의 요청을 응용 서비스가 요구하는 형식으로 변환(해석)
		* 실행 결과를 사용자에게 알맞은 형식으로 변환
	* 응용 서비스는 표현영역에 의존하지 않는다.
	
## 6.2 응용서비스의 역할
* 사용자가 요청한 기능을 실행
	* 하기 위해서 리포지터리에서 도메인 객체를 가져와 사용한다.
* 표현 영역 입장에서 보았을 때, 도메인 영역과 표현 영역의 창구 역할
* 도메인 객체간의 흐름을 제어하므로 단순한 형태를 갖는다.
	* 복잡하다면 응용 서비스가 도메인 로직의 일부를 구현하고 있을 가능성이 높다.
	* -> 코드중복, 로직 분산등 코드 품질에 안좋은 영향을 줌
* 데이터 일관성 유지를 위해 트랜잭션 처리 담당
* 접근 제어와 이벤트 처리 - 뒤에서 살펴보자

### 6.2.1 도메인 로직 넣지 않기
* 응용서비스에서 도메인 로직을 구현해서는 안된다. 코드 품질 이슈 발생!
	* 코드의 응집성이 떨어진다(하나의 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다)
	* 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.
		* ex) 암호 변경/회원정보수정/계정정지 등 여러곳에서 암호 확인 코드를 구현하면?
			* 중복 방지를 위해 응용 서비스 영역에 별도의 보조 클래스를 만들 수도 있지만
			* 그럴거면 그냥 도메인 영역에 만들어놓고 도메인 기능을 사용하도록 해아.
* 위 두가지 이슈는 결과적으로 코드 변경을 어렵게 만든다.
	* 소프트웨어 가치의 하락.
	
## 6.3 응용서비스의 구현
* 응용 서비스는 표현 영역과 도메인 영역을 연결 -> 디자인 패턴에서의 파사드 역할
	* https://live-everyday.tistory.com/210 - 퍼사드는 내부 시스템의 복잡도를 감추기 위해 복잡한 기능을 감싸고 상호작용할 더 단순한 메소드를 제공하는 계층이라고 생각할 수 있다. 
* 이 절에서는 응용 서비스의 구현시 고려할 사항과 트랜잭션 같은 구현기술의 연동에 대해 살펴본다.

### 6.3.1 응용서비스의 크기
* 하나의 도메인에 여러 가지 기능들이 상존할 때, 응용서비스는 일반적으로 다음 두가지 중 한가지 방법으로 구현한다.
	* 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
	* 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

* 한 클래스에서 모두 구현하는 경우
	* 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다.(장점)
	* 한 서비스 클래스의 크기(줄 수) 가 커진다(단점 - 관련 없는 코드가 뒤섞여 코드 이해헤 방해가 됨)
	* 일단 코드가 모이기 시작하면 분리하는 것이 좋은 상황일 때도 습관적으로 기존 클래스에 끼워넣기를 하게 된다.
* 구분되는 기능별로 구현하는 경우 - 권장
	* 한 응용서비스 클래스 내에서 1~3개의 기능을 구현한다.
	* 클래스 개수는 많아지지만, 코드 품질을 일정 수준으로 유지하는 데 도움이 된다.
	* 각 클래스 별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.
	* 중복해서 동일한 코드를 구현할 가능성은 공통 로직을 별도 클래스로 구현하여 코드 중복을 방지한다.
### 6.3.2 응용서비스의 인터페이스와 클래스
* 인터페이스가 필요할까?
	* 구현 클래스가 여러개 이거나 런타임에 구현객체를 교체해야 할 때
		* 응용서비스에서는 두 경우 모두 드물다.
		* 구조가 복잡해지므로 응용 서비스에서는 명확하게 필요하기 전까지는 좋은 선택이라고 볼수 없다.
	* TDD의 경우
		* 표현영역부터 개발한다면 응용서비스를 미리 구현할 수 없으므로 인터페이스를 이용해서 컨트롤러의 구현을 완성해 나갈 수 있다.
		* 도메인 영역이나 응용 영역의 개발을 먼저 시작하면 응용서비스 클래스가 먼저 만들어진다.
			* 표현영역 단위 테스트를 위해 가짜객체를 위한 인터페이스가 필요할 수도 있다
			* 하지만 Mockito같은 도구는 클래스에 대한 대역객체 생성이 가능하므로 응용서비으에 대한 인터페이스 필요성이 낮아진다.

### 6.3.3 메서드 파라미터와 값 리턴
* 응용 서비스에서는 도메인을 이용해서 사용자가 요구한 기능을 실행하는데 필요한 값을 파라미터로 전달받아야 한다.
	* 각 값을 개별 파라미터로 전달 받거나 값전달을 위한 별도 데이터 클래스를 만들어 전달 받을수 있다.
	* Spring MVC는 Web Request파라미터를 자바 객체로 변환하는 기능을 제공하므로
	* 요청 파라미터가 두 개 이상 존재하면 데이터 전달을 위한 별도 클래스를 사용하는 것이 편리하다.
* 응용 서비스의 결과를 표현 영역에서 사용해야 할 때
	* 응용 서비스 메서드에서 필요한 데이터를(만!) 리턴한다.
		* 응용 서비스에서 애그리거트 객체를 그대로 리턴할 수도 있지만 로직실행이 응용/표현 두 곳에서 가능해진다.
		* 애그리거트를 리턴 받아도 표현 계층에서 실행하지 않는 다는 규칙을 정할 수는 있지만, 애초에 가능성을 차단하자.

### 6.3.4 표현 영역에 의존하지 않기
* 응용 서비스의 파라미터 타입은 표현 영역과 관련된 타입을 사용하지 않아야 한다.
	* 표현 영역에 대한 의존 발생
		* 응용 서비스만 단독으로 테스트 하기 어려워짐
		* 표현 영역의 구현 변경시 응용서비스 구현도 변경되어야 함
		* **심각** 응용 서비스가 표현 영역의 역할까지 침범할 수 있다.
			* 응용서비스에서 세션이나 쿠키 처리가 가능해짐. -> 표현 영역의 응집도 깨짐
* 응용 서비스의 파라미터 타입은 표현 영역과 관련된 타입을 사용하지 않아야 한다. (다시 한번 강조)

### 6.3.5 트랜잭션 처리
* 한 동작에 연결된 동작이 제대로 처리되지 않으면 안된다.
* 따라서 트랜잭션 관리가 중요함.
* 스프링에서는 간단한 어노테이션으로 트랜잭션 기능을 사용할 수 있다.(@Transactional)

## 6.4 표현영역
* 표현영역의 책임
	> * 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공/제어
	> * 사용자의 요청을 알맞은 응용서비스에 전달하고 결과를 사용자에게 돌려준다.
	> * 사용자의 세션을 관리한다.
* 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공/제어
	* ex) 글쓰기 요청시 폼화면 응답 -> 글쓰기 완료시 응용서비스에 글 내용 전달하고 결과를 응답
* 사용자의 요청을 알맞은 응용서비스에 전달하고 결과를 사용자에게 돌려준다.
	* ex) 비밀번호 변경요청을 받아서 응용서비스에 적절한 파라미터 형식으로 변환하여 호출하고 결과를 응답.
	* 6.3.3 에 언급했듯이 "Spring MVC는 Web Request파라미터를 자바 객체로 변환하는 기능을 제공"
	
	* 실행 결과를 알맞은 형식으로 제공하는 것도 주요 역할
		* 성공했을 때, 익셉션이 발생했을 때 각각 알맞은 처리를 해서 메시지/결과를 출력해줘야 함.
* 사용자의 세션을 관리한다.	
	* 쿠키나 서버 세션을 이용해서 연결 상태를 관리
	* 권한 검사와도 연결되는 데, 6.6에서 재논의 한다.
	
## 6.5 값 검증
* 표현 영역, 응용 서비스 두 곳에서 모두 수행할 수 있는데
	* 원칙적으로 모든 값에 대한 검증은 응용서비스에서 처리한다.
	* 그런데, 표현 영역에는 잘못된 값을 사용자에게 알려주고 다시 입력받을 책임이 있다.
	* 응용 서비스 영역에서 각 값이 유효한 지 일일히 확인하여 익셉션을 발생시키게 되면 사용자에게 좋지 않은 UX를 제공하게 된다.
		* 넣고 실패하고를 반복하기보다는 한 번에 모든 잘못 입력한 값을 알고 싶음
	* 에러 코드를 모아 하나의 익센션으로 발생시키는 방법도 있다.
* 표현영역에서 필수 값을 검증하는 경우도 있는데, 스프링에서는 Validator인터페이스를 별도로 제공하므로 활용하자.
* 이렇게 할 경우 검증의 역할을 다음과 같이 분리 할 수 있다.
	> * 표현 영역 : 필수 값, 값의 형식, 범위 등을 검증한다
	> * 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류를 검증한다.
* 저자의 경우 위처럼 검증을 분리해서 진행하다가 모두 응용서비스에서 검증을 하는 편으로 바뀌었다고 한다.
	* 프레임워크의 제공 기능을 사용할 때보다 코드가 늘어나지만 응용서비스의 완성도가 높아지는 이점이 있다.
	* 음...그리고 값의 범위 같은 경우는 비즈니스 로직적인 부분이 있기도 해서가 아닐까? 아니면 로직에 따라 없어도 되는 값등등..
	
## 6.6 권한 검사
* 권한 검사 자체는 복잡한 개념이 아니지만, 시스템마다 권한의 복잡도는 다르다.
* 스프링 시큐리티 같은 프레임워크가 다양한 상황을 충족하기 위해 유연하고 확장 가능한 구조를 갖는다. == 복잡하다.
	* 보안 프레임워크에 대한 이해가 부족하다면 프레임워크 도입보다 적절한 검사기능 구현이 유지보수에 유리할 수 있다.
* 권한 검사 위치와 기본적인 내용
	* 표현영역 : 인증된 사용자인지 검사 / URL별 권한 검사
		* 서블릿 필터 사용 혹은 스프링 시큐리티의 필터를 사용해서 웹 접근을 제어
	* 응용서비스 : 메서드 단위로 권한 검사 
		* 코드에서 직접할 수도 있지만  스프링 시큐리티의 @preAuthorize 같은 애너테이션을 활용
	* 도메인 영역 : 개별 도메인 객체 단위로 검사를 하는 경우
		* 직접 권한 검사를 구현해줘야 하므로 구현이 복잡해짐
		* 스프링 시큐리티같은 보안 프레임워크를 확장할 수도 있지만 
			* 도메인 별로 다른 로직을 확장하려면 프레임워크에 대한 높은 이해가 필수적이다.
			* 이해도가 낮가면 직접 구현이 유지보수에 유리하다.(본인 뿐 아니라 전체 팀원의 이해수준을 고려해야 할 것 같다)

## 6.7 조회 전용 기능과 응용 서비스
* 5장에서 5회전용 모델과 DAO에 대한 내용을 다루었는데 이런경우 서비스 코드가 단순히 조회전용 기능을 호출하는 형태로 끝날 수 있다.
* 서비스에서 수행하는 추가 로직이 없고 단일쿼리 수행 조회로직이어서 트랜잭션도 필요가 없다.
	* 이런 경우는 서비스를 만들필요 없이 표현영역에서 바로 조회전용 기능을 사용해도 문제가 없음.
	* 응용서비스 없이 조회 전용기능에 접근하는 것이 이상할 수 있지만, 굳이 별다른 기여가 없는 서비스를 만들 필요가 없다!
	* 11장 CQRS 에서 다시 살펴보자.
