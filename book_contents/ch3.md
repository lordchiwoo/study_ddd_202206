# Chapter 3. 애그리거트

## 3.1 애그리거트
* 상위모델에 대한 이해 없이 나열된 모델들만을 보고 개념을 파악하기는 힘들다.
  * 도메인 객체모델이 복잡해지면 나무를 보고 숲을 못보는 현상이 발생
  * 코드를 변경하고 확장하는것이 어려워짐.
  * 전체적인 그림을 알아야 전체 모델을  망가뜨리지 않으면서 추가요구사항을 반영가능.
    * But 부분만 이해한 상태에서는 코드 변경을 최대한 회피하는 쪽으로 협의하게 됨.
    * "돌아만 가는" 코드를 만들수는 있지만 장기적으로는 기술부채가 됨.
* 상위수준에서 모델을 조망하기
  * 관련된 객체를 하나의 군으로 묶어서 상위수준에서 모델간의 관계를 파악
  * 이해 + 일관성의 관리 기준이 된다.
  * 애그리거트 단위로 일관성을 관리해서 복잡한 도메인을 단순한 구조로 만들어준다.
    * 복잡도가 낮아지면서 기능의 확장/변경에 필요한 노력도 줄어든다.
    
* 관련된 모델을 하나로 모았기 때문에
  * 도메인 규칙에 따라 일부를 만들 필요가 없는 경우도 있지만
  * 대부분 유사하거나 동일한 라이프 사이클을 가지게 된다.
  
* 경계를 갖는다 : 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
  * 자기 자신만 관리해야 한다
  * 도메인 규칙과 요구사항에 기반하여 경계를 설정한다.
  
* 생성하고 변경하는 주체가 다르다면 밀접한 연관관계가 있더라도 다른 애그리거트로 다룬다.
  * ex) 상품(관리자가 생성/변경)과 리뷰(고객이 생성/변경)
    * 서로의 변경이 서로에게 영향을 미치지 않기 때문에 다른 애그리거트에 속하게 된다.
    
* 저자의 경험에 비추어보면 다수의 애그리거트가 한개의 엔티티 객체만 갖는 경우가 많았다.


## 3.2 애그리거트 루트와 역할
* 도메인 규칙과 데이터 일관성(Consistency)
  * 도메인 규칙을 지키려면 소속된 모든 객체가 정상상태를 가져야 한다.
  * 상태를 관리할 주체가 필요함 : 루트 엔티티!
    * 애그리거트에 속한 객체는 직,간접적으로 루트엔티티에 소속된다.
    
### 3.2.1 도메인 규칙과 일관성
* 루트의 역할은 단순히 포함관계로 끝나는 것이 아니라 애그리거트의 일관성이 깨지지 않도록 하는 것.
  * 루트는 애그리거트가 제공하는 도메인 기능을 제공한다.
  * 제공하는 메서드는 도메인 규칙에 따라 일관성이 깨지지 않도록 구현해야 한다.
  * 애그리거트 외부에서 애그리거트 내의 객체를 직접 변경해서는 안된다.
    * 애그리거트의 토메인규칙을 강제할 수 없어 모델의 일관성이 깨질 수 있다.
    * 외부에서 처리하게 되면 일관성을 위해 동일한 검사로직이 중복으로 구현될 가능성이 높아진다.
    * 중복으로 구현된 로직은... 알지?
  * 따라서 다음 두 가지를 습관적으로 적용하여 루트를 통해서만 도메인 로직을 구현하도록 한다.
  > * 단순히 필드를 변경하는 `set` 메서드를 public으로 만들지 않는다.
    * public `set` 메서드는 도메인의 의미나 의도를 표현하지 못하고 도메인로직을 응용/표현 영역으로 분산시킨다.
      * 응집되지 않은 도메인 로직은 유지보수에 더 많은 수고가 필요해진다.
    * 의미가 드러나는 메서드 이름을 사용해서 구현하자.
  > * 밸류타입은 불변으로 구현한다.
    * 밸류 객체의 값을 변경할 수 없으면 애그리거트 외부에서 밸류객체의 상태를 변경할 수 없게 된다.
      * 외부에서 내부상태를 변경하지 못하므로 일관성이 깨질 가능성이 낮아진다.
      * 값변경을 위해서는 새로운 객체를 할당해야하므로 루트가 제공하는 메서드에 전달할 수밖에 없음 (good!)
      
  * 위 두가지 습관을 통해서 루트가 도메인 규칙을 올바르게 구현하기만 하면 전체의 일관성을 유지할 수 있다.
  
### 3.2.2 애그리거트 루트의 기능 구현
* 루트는 내부의 다른 객체를 조합하여 기능을 완성한다.
  * 상태 참조 이외에도 별도 클래스로 분리시 기능을 위임하기도 한다.
    * 분리한 엔티티 내의 상태만 참조하여 처리 가능해야 한다 (1장의 배송지 변경 기억나쥬?)
    * 외부에서 내부 엔티티의 기능을 실행하게 되면 연관된 다른 데이터의 일관성이 깨질수 있다.
      * 애초에 불변으로 구현하여 변경을 불가능하게 하고
      * 불변으로 구현할 수 없다면 변경기능을 패키지나 protected 범위로 한정해서 외부에서 실행할 수 없도로 제한한다.
      * 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문.
      
### 3.2.3 트랜잭션 범위
* 트랜잭션 범위는 작을수록 좋다.
  * Lock이 걸리는 범위가 커지면 동시에 처리 가능한 트랜잭션 개수가 줄어든다 -> 처리량 저하
  * 따라서 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
    * 애그리서트는 다른 애그리거트를 변경하지 않는다!
      * 두개의 애그리거트를 한 트랜잭션에서 수정하게 되므로 좋지 않다.
      * 애그리거트가 자신의 책임범위를 넘어 다른 애그리거트의 상태까지 관리하게 됨. (결합도 증가 -> 수정비용 증가)
    * 부득이한 경우에는 애그리거트 내에서 처리하지 말고 응용서비스에서 두 애그리거트를 수정하도록 구현한다.
      * 애그리거트 내부에서는 자신의 도메인만 책임지고 두개이상의 애그리거트가 연관되면 상위로 위임한다.
    * 도메인 이벤트를 사용해서 한 트랜잭션에서 동기/비동기로 다른 애그리거트를 변경하는 코드를 작성할 수 있다.(10장에서 다시보자)
    
    *다음의 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 "고려"할 수 있다.
    > * 팀 표준 : 팀/조직의 표준에 따라 사용자 유즈케이스와 관련된 응용서비스의 기능을 한 트랜잭션으로 실행해야 하는경우
    > * 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 일관성 처리를 위해서
    > * UI 구현의 편리 : 운영자의 편리함을 위해 한 화면에서 여러 주문의 상태를 변경하고 싶을 경우
    
    
    

## 3.3 애그리거트와 리포지터리
* 애그리거트는 개념상 한 개의 완전한 도메인 모델 => 리포지터리와 1:1 매칭된다.
* 물리적으로 별도의 테이블에 저장된다고 해서 각각 리포지터리를 만들지 않도록 한다.
* 일반적으로 save / findById 두가지 메서드를 리포지터리에서 기본으로 제공한다.
  * 필요에 따라 다양한 조건으로 검색하거나 애그리거트를 삭제 하는 메서드를 추가할 수 있다.

* 기술에 따라서 애그리거트의 구현도 영향을 받는다.
  * JPA 사용시 DB 관계형 모델에 객체의 도메인 모델을 맞춰야 할 때도 있다.
    * 레거시 DB를 사용하거나
    * 팀내 DB설계 표준을 따라야 할 경우 
  * 밸류타입인 도메인 모델을 @Component가 아닌 @Entity를 이용해야 할 수도 있다.
  > * @Component : JPA에서 밸류 타입 매핑시 사용
  > * @Entity : JPA에서 엔티티 타입 매핑시 사용
  
* 애그리거트는 개념적으로 하나 : 리포지터리는 애그리거트 전체를 영속화 해야한다.
  * 루트에 매핑되는 테이블 뿐만 아니라 모든 구성요소에 매핑된 테이블에 데이터를 저장
  * 애그리거트를 구할 때도 완전한 애그리거트를 제공해야 한다.
    * 그렇지 않으면 NPE가 발생할 수 있다.
    
  * 저장소로 무엇을 사용하든 애그리거트의 상태 변경은 모두 원자적으로 저장소에 반영해야 한다.
    * 저장소에서의 데이터 일관성을 유지!
    * RDBMS에서는 트랜잭션 / 몽고DB에서는 1 애그리거트-1 문서
    * 4장에서 RDBMS/JPA를 사용하여 리포지터리를 구현하는 방법을 살펴보자
    

## 3.4 ID를 이용한 애그리거트 참조
* 애그리거트도 다른 애그리거트를 참조한다.
  * 필드를 통해 직접 참조하면 구현의 편리함을 제공한다. 하지만
  > * 편한 탐색 오용
  > * 성능에 대한 고민
  > * 확장 어려움
  을 야기할 수 있다.
  
    * 편한 탐색 오용
      * 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할수 있으면 다른애그리거트의 상태를 쉽게 변경할 수 있게 된다.
      *의존 경합도가 높아지면서 결과적으로 애그리거트의 변경을 어렵게 만든다.
      
    * 성능에 대한 고민
      * 직접참조시 JPA에서 Lazy/Eager로딩이 가능한데, 무엇을 사용할지는 기능에 따라 달라진다.
      * 데이터 보여줄때는 즉시로딩
      * 상태 변경기능 실행시에는 지연로딩이 유리할 수 있다
      * 경우의 수를 고민하는 것 자체가 문제야... 소는 누가.....
      
    * 확장
      * 부하 분산을 위해 시스템을 분리할 시점이 오게되면 다른 애그리거트 루트 참조가 어려워진다

  * 세가지 문제를 완화하기위해 ID를 이용해서 다른 애그리거트를 참조하는 것이다.
    * DB에서 외래키로 참조하는 것과 비슷하다.
    * ID참조를 사용하면 모든 객채가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 연결된다.
      * 애그리거트 경계 명확화
      * 애그리더트간 물리적 연결 제거 -> 모델의 복잡도 감소
      * 의존성 제거 -> 응집도 증가
      * 구현 복잡도도 낮아진다. -> Lazy/Eager를 고민할 필요가 없어진다
        * 필요하면 응용서비스에서 ID를 이용해서 로딩해서 쓰면 된다.
        * 애그리거트 수준에서 지연로딩을 하는 것과 동일한 결과를 만든다.
      * 또한 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지할 수 있다.
        * 직접 참조하지 않으므로 애초에 다른 애그리거트 상태를 변경할 수 없어짐.
      * 애그리거트 별로 다른 구현기술을 사용하는 것도 가능해진다.
    
  * ***`그러면 언제 직접참조를 사용해야 할까???`***
  
### 3.4.1 ID를 이용한 참조와 조회성능
* 다른 애그리거트를 ID로 참조하면 조회속도가 문제가 될수 있다. 
  * 지연 로딩과 같은 효과를 만들기 때문에 N+1 문제같은 것이 발생할 수 있다.
* 회피를 위해서 조인을 사용해야 하는데 가장 쉬운방법은 ID참조->객체참조 + 즉시로딩
  * 응?
  
* 그래서 사용합니다. 조회전용 쿼리
  * 데이터 조회를 위한 별도의 DAO를 만들고 DAO의 조회메서드에서 조인을 이용해 한번의 쿼리로 필요한 데이터를 로딩
  * 조회 화면에 필요한 애그리거트 데이터를 한번의 쿼리로 로딩
  * JPQL을 사용할 수도 있지만, 복잡하거나 특화된 기능을 사용해야 한다면 조회를 위한 부분만 마이바티스같은 기술을 이용해 구현할 수 있다.
  * 기술에 집착하지 말고 실용적인 방법을 쓰자. JPA만 쓴다고 간지가 나는게 아니라 적절한 기술을 적절한 곳에 써야 한다.
  
* 애그리거트마다 다른 저장소 사용시 한방쿼리가 안 되는 문제는?
  * 캐시를 적용하거나 조회전용 저장소를 별도로 구성한다
    * 코드의 복잡도 상승을 감수하고 시스템의 처리량을 높일 필요가 있다면.

* 5장에서는 조회전용 쿼리를, 11장에서는 CQRS (명령모델과 조회전용모델의 분리구현 패턴)을 다룰 것입니다.

## 3.5 애그리거트 간 집합 연관
* 애그리거트간 1:N, M:N 연관
  * 컬렉션을 이용한 연관이다
  * 대표적인 예 : 카테고리-상품 연관
* 1:N관계는 Set과 같은 컬렉션으로 표현한다.
  * 모두 조회할 경우 실생속도에 문제가 발생할 수 있다.
  * 개념적으로 1:N이더라도 이러한 문제의 발생소지로 실제구현에 반영하지 않는다.
  * 대신 상품입장에서 N:1로 카테고리의 연관을 추가하고 그 연관을 이용해서 특정 카테고리에 속한 상품 목록을 구할 수 있다.
  ```JAVA
  public class Product {
      // ...
      private CateogryId category;
      //...
  }

  public class ProductListService {
      public Page<Product> getProductOfCategory(Long categoryId, int page, int size) {
          Category category = categoryRepository.findById(categoryId);
          checkCategory(category);
          List<Product> products = productRepository.findByCategoryId(category.getId(), page, size);
          int totalCount = productRepository.countByCategoryId(category.getId());
          return new Page(page, size, totalCount, products);
      }
  }
  ```
* M:N연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.
  * 1:N처럼 M:N도 실제 요구사항을 고려하여 구현에 포함시킬지를 결정해야한다.
  * 1) 특정 카테고리에 속한 상품 목록 - 각 상품이 속한 모든 카테고리를 표시하지 않는 경우가 많다. 
  * 2) 상품 상세 -모든 카테고리를 표시해줄 필요가 있다 
  * 1+2) 개념적으로는 양방향 M:N이지만 실제 구현에서는 상품->카테고리의 단방향 M:N연관만 적용해도 된다.
  
  * RDBMS에서 M:N연관은 조인테이블을 사용해서 구현한다.
  ![조인 테이블](https://github.com/lordchiwoo/study_ddd_202206/raw/main/book_contents/fig3.9.png)
  ```JAVA
	@Entity
	@Table(name = "product")
	public class Product {
		@EmbeddedId
		private ProductId id;
		
		@ElementCollection  //카테고리 ID목록을 보관하기 위한 밸류타입의 컬렉션 매핑
		@CollectionTable(name = "product_category",
			joinColumns = @JoinColumn(name = "product_id"))
		private Sets<CategoryId> categoryIds;
		//...
	}
	////////////////////////////////////////////////////////////////
	//member of 연산자를 사용한 특정 카테고리 소속 Product 목록 구하기
	@Repository
	public class JpaProductRepository implements ProductRepository {
		@PersistenceContext
		private EntityManager entityManager;

		@Override
		public List<Product> findByCategoryId(CategoryId categoryid, int page, int size) {
			TypedQuery<Product> query = entityManager.createQuery(
				"select p from Product p " + 
				"where :catId member of p.categoryIds order by p.id.id desc", Product.class);
				//:catId member of p.categoryIds ==> categoryIds컬렉션에 catId로 지정한 값이 존재하는지 검사하기위한 검색조건
			query.setParameter("catId", categoryId);
			query.setFirstResult((page - 1) * size);
			query.setMaxResults(size);
			return query.getResultList();
		}
	}
	
  ```

  * JPA를 이용한 모델매핑 / 컬렉션 사용시의 성능관련 문제는 4장에서 만나요.
  
## 3.6 애그리거트를 팩토리로 사용하기
* 상품 등록이 상점 계정의 상태를 체크해야할 경우 상품의 도메인 로직이 응용서비스에 노출될 수 있다.
  * ....음? 상품/스토어 두개의 도메인이니까 응용에서 처리하는거 아닌가?
  * 는 Product의 생성 주체가 Store이므로 논리적으로 하나의 도메인 기능이라고 한다....
  * 따라서 응용 계층에서 Store로 Product 생성 기능을 옮기게 되면 Store애그리거트에서 Product애그리거트를 생성하는 팩토리 역할을 한다
  ```JAVA
	public class Store {
		public Product createProduct(ProductId newProductId, ...) {
			if (isBlocked()) throw new StoreBlockedException();
			return new Product(newProductId, getId(), ...);
		}
	}
	////////////////////////////////////////////////////////////////
	// 팩토리 기능을 이용해서 Product를 생성하는 응용서비스
	public class RegisterProductService {
		public ProductId registerNewProduct(NewProductRequest req) {
			Store store = storeRepository.findStoreById(req.getStoreId());
			checkNull(store);
			ProductId id = productRepository.nextId();
			Product product = store.createProduct(id, /*...*/);
			productRepository.save(product);
			return id;
		}
	}
	
  ```
  
  * 응용서비스에서 Store의 상태를 확인하지 않고 Store에서 자신의 상태를 이용해서 Product를 생성할 수 있는지 확인한 뒤에 Product를 생성한다.
    * 그럼 만약에 Store 외의 상태를 확인해야 한다면 응용서비스로 올라가는게 맞나?
	* 어쨌든 로직의 변경시에도 Store만 수정하고 응용서비스는 안건드리게 되었고 응집도도 높아졌다. -> 애그리거트를 팩토리로 사용할 때 얻을 수 있는 장점.
  * '한' 애그리거트의 상태/데이터를 이용해 다른 애그리거트를 생성하는 경우에 팩토리 메서드를 구현하면 좋다.
    * 데이터의 일부를 직접 제공하면서 동시에 중요한 도메인로직을 구현할 수 있다.
    * 많은 정보를 알아야 한다면 해당 애그리거트에서 다른 팩토리에 위임할 수도 있다.
  ```JAVA
	public class Store {
		public Product createProduct(ProductId newProductId, ProductInfo pi) {
			// 다른 팩토리에 위임했지만 중요한 도메인 로직은 한 곳에 남겼다.
			if (isBlocked()) throw new StoreBlockedException();
			return new ProductFactory.create(newProductId, getId(), pi);
		}
	}
	
  ```
  
