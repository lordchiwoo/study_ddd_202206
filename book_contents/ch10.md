# Chapter 10. 이벤트

## 10.1 시스템 간 강결합 문제
* 구매 취소 -> 환불 처리 필요 -> 환불 기능 실행 주체는 ?
	* 주문 도메인 엔티티의 경우 - 환불기능을 제공하는 도메인 서비스를 파라미터로 전달받고 취소 도메인 기능에서 도메인 서비스를 실행
	* 응용서비스의 경우 - 결제 시스템은 보통 외부에 존재하므로 RefundService는 외부에 있는 결제시스템이 제공하는 환불 서비스를 호출한다.
	
* 이때 두가지 문제가  발생 가능
	1. 외부 서비스가 비정상인 경우 트랜잭션 처리 - 환불과정에서 익셉션이 발생하면 트랜잭션을 롤백해야 하는가?
		- 주문 취소 롤백
		- 주문은 취소하고 환불만 나중에 재시도
	2. 환불 처리 외부 시스템의 응답시간이 길어지면 대기시간도 길어진다.
		- 외부 서비스의 성능에 직접적인 영향
* 추가로 설계상 문제가 발생
	1. 결제로직과 주문로직이 섞임 (주문 취소 / 결제 취소(환불))
		- 결제 도메인의 변경으로 인해 주문도메인 객체의 코드가 변경되어야 할 수도 있음.
	2. 취소했다는 내용을 통지해야 한다면?
		- 로직이 섞이고 트랜잭션 처리가 더 복잡해 진다.

* 이게 다~~ 주문 바운디드컨텍스트와 결제 바운디드컨텍스트 간의 강결합 때문이다.
	* 그래서 이벤트를 사용합니다.
	* 특히 비동기 이벤트는 두 시스템간의 결합을 크게 낮출 수 있다.
	
## 10.2 이벤트 개요
* 이벤트 :  과거에 벌어진 어떤 것
	* 이벤트 발생 ==  상태가 변경됨.
	* 이벤트가 발생하면 원하는 동작을 수행하는 기능을 구현해야 한다.
	* ~~ 할 때, ~~가 발생하면, 만약 ~~하면 : 도메인의 상태 변경과 관련된 경우가 많고 이벤트를 통해 구현 가능하다.
		* ex) 주문 취소할 때 이메일을 보낸다 : 주문 취소됨 이벤트

### 10.2.1 이벤트 관련 구성요소
* 도메인 모델에 이벤트를 도입하려면 네가지 요소를 구현해야 한다. 
	* 이벤트
	* 이벤트 생성 주체 : 엔티티/도메인서비스와 같은 도메인 객체가 도메인 로직을 실행하여 상태가 바뀌면 관련 이벤트를 발생시킨다.
	* 이벤트 핸들러 : 이벤트 생성주체가 발행한 이벤트에 반응해서 이벤트에 담긴 데이터를 이용해 원하는 기능을 실행한다.
	* 이벤트 디스패쳐(퍼블리셔) : 이벤트 생성주체와 핸들러를 연결 
	* 생성주체 -> 디스패처 -> 핸들러 로 이벤트가 이동한다
	* 디스패처 구현 방식에 따라 이벤트 생성과 처리가 동기/비동기로 실행된다
	 

### 10.2.2 이벤트의 구성
* 이벤트에 대한 정보를 담는다 
	* 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현
	* 이벤트 발생 시간
	* 추가 데이터 : 주문번호/신규 배송지 정보 등 이벤트와 관련된 정보
* 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하므로 이벤트 이름에는 과거 시제를 사용한다

```JAVA
public class Order {
	// 주문 도메인에서 배송지 변경 기능 실행
  public void changeShippingInfo(ShippingInfo newShippingInfo) { 
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo);
	// 디스패처를 통해 이벤트를 전파
    Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo)); //과거 시제 사용
  }
  ...
}
/////////////////////////////////////
public class ShippingInfoChangedHandler{

	// 발행된 이벤트의 핸들러
  @EventListener
  public void handle(ShppingInfoChangedEvent evt) {
    shippingInfoSynchronizer.sync(
      evt.getOrderNumber(),
      evt,getNewShippingInfo();
    )
  }
}
```
* 이벤트에 필요한 정보를 담지 않는다면 핸들러에서 주문데이터를 로딩하는 작업등을 수행해야 하므로 가급적 이벤트에 정보를 모두 담도록 한다.

	
### 10.2.3 이벤트의 용도
1. 트리거
	* 도메인의 상태가 바뀔 때 다른 후처리가 필요한 경우 후처리를 실행하기 위한 트리거
		* 주문 취소 -> 주문취소 이벤트 -> 환불 처리
		* 예매 완료 -> 예매완료 이벤트 -> SMS 통지
2. 서로 다른 시스템간의 데이터 동기화
	* 배송지 변경(주문 도메인) -> 배송지 변경 이벤트 -> 배송지 정보 동기화(외부 배송서비스)
	
### 10.2.4 이벤트의 장점
* 서로 다른 도메인 로직이 섞이는걸 방지할 수 있다.
	* 주문도메인에서는 주문 취소 처리 후 주문취소 이벤트만 발행하고 결제 관련 이슈는 처리하지 않음
	* 나머지는 이벤트 핸들러에게 모두 위임한다.
	* 기능 추가시에도 이벤트 핸들러를 추가하면 되고 주문 도메인을 변경할 필요가 없어진다.

## 10.3 이벤트, 핸들러, 디스패처 구현
* 이벤트 클래스 :  이벤트를 표현
* 디스패처 : 스프링의 ApplicationEventPublisher를 사용
* Events : 이벤트를 발행하고 디스패처에 전달
* 핸들러 : 이벤트를 수신해서 처리 - 스프링 제공 기능 사용

### 10.3.1 이벤트 클래스
* 이벤트 자체를 위한 상위 타입은 존재하지 않는다.
	* 공통의 기능( 이벤트 발생시점 등 )을 처리하기 위해 관련 상위 클래스를 만들 수도 있다.
	* 클래스 명을 정할 때 과거시제를 사용해야한다는 점을 유의하고 명시적으로 Event를 붙이는것은 취사 선택
	* 앞서 설명한 것 처럼 필요한 최소한의 데이터를 포함해야한다. (주문 취소 이벤트 - 주문번호 데이터)
	
### 10.3.2 Events클래스와 ApplicationEventPublisher
* Events 클래스를 ApplicationEventPublisher를 사용해서 이벤트를 발생시키도록 구현
	
```JAVA
public class Events {
    
    private static ApplicationEventPublisher publisher;

    static void setPublisher(ApplicationEventPublisher publisher) {
        Events.publisher = publisher;
    }

	// publishEvent메서드를 이용해 이벤트를 발행
    public static void raise(Object event) {
        if(publisher != null) {
            publisher.publishEvent(event);
        }
    }
}
/////////////////////////////////////

//스프링 설정 클래스 작성
@Configuration
public class EventsConfiguration {
    @Autowired
    private ApplicationContext applicationContext; 

    @Bean // InitializingBean : 스프링 빈객체 초기화에 사용되는 인터페이스
    public InitializingBean eventsInitializer() {
		// ApplicationEventPublisher를 상속하는 Context를 Publisher로 전달
        return () -> Events.setPublisher(applicationContext); 
    }

}
```

### 10.3.3 이벤트 발생과 이벤트 핸들러
* @EventListener 애너테이션을 사용해 핸들러를 구현하고
* Events.raise()를 통해 이벤트를 발생시켜 전달한다.
* publishEvent()메서드에 이벤트 타입 객체가 전달되면 해당 이벤트 클래스 값을 가진 @EventListener를 찾아 실행한다.

### 10.3.4 흐름 정리
* 도메인 상태변경과 이벤트 핸들러가 같은 트랜잭션 범위에서 실행된다.
	1. 응용서비스 : 도메인 기능 실행
		2. 도메인 : Events.raise()
			3. Events : ApplicationEventPublisher를 이용해 이벤트 출판
				4. ApplicationEventPublisher : Handler를 찾아 실행하고 
					* 핸들러 :  이벤트에 따라 구현된 동작을 수행
				5. ApplicationEventPublisher : 결과를 리턴
			6. Events : 결과를 리턴
		7. 도메인 : 결과를 리턴
	8. 응용서비스 : 동작 완료


## 10.4 동기 이벤트 처리 문제
* 강결합 문제는 해결되었지만 외부서비스 영향 문제가 남아 있다.
	* 이벤트 핸들러가 외부 환불서비스를 호출하는 경우 외부 서비스의 성능저하가 바로 내 시스템의 성능 저하로 연결된다.
	* 또한 트랜잭션도 문제가 된다. refund에서 익셉션 발생시 cancel메서드의 트랜잭션을 롤백해야 하는가? == 구매취소 실패
* 비동기 처리 / 이벤트와 트랜잭션 연계를 알아보자.

## 10.5 비동기 이벤트 처리
* A하면 이어서 B하라 
	* 일반적으로 일정 시간 안에만 후속 조치를 처리하면 되는경우가 많다.
	* 실패시 일정간격으로 재시도를 하거나 수동처리를 해도 상관없는 경우가 있다.
		* ex) 이메일 인증 - 메일 재전송 요청
	* 이러한 A하면 "최대 언제까지" B하라 요구사항은 이벤트 비동기 처리로 구현할 수 있다.
		* A이벤트 발생시 별도 스레드로 B핸들러를 실행
* 방법
	1. 로컬 핸들러 비동기 실행
	2. 메시지큐 사용
	3. 이벤트 저장소와 포워더 사용
	4. 이벤트 저장소와 이벤트 제공 API


### 10.5.1 로컬 핸들러 비동기 실행
* @EnableAsync 애너테이션을 사용해 비동기 기능 활성화
* 이벤트 핸들러에 @Async 애너테이션 추가
* 핸들러가 별도 스레드에서 실행된다.

### 10.5.2 메시징 시스템을 이용한 비동기 구현
* 이벤트 디스페처가 이벤트를 메시지큐에 전송
* 메시지큐는 메시지 리스터에 이벤트를 전달
* 리스너는 알맞은 이벤트 핸들러를 이용해 이벤트를 처리
* 이벤트의 저장과 Read는 별도 스레드/프로세스로 처리

* 필요한 경우 이벤트 발생 도메인 기능과 메시지큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 한다.
	* 글로벌 트랜잭션이 필요 - 안전하게 메시지큐에 전달하지만 전체성능이 떨어진다.
	* 글로벌트랜잭션 미지원 메시징 시스템도 있음.
* 동일 JVM에서 비동기처리를 위해 메시지 큐를 사용하는 것은 시스템을 복잡하게 만들뿐이다.

* 카프카나 RabbitMQ등을 사용
	* RabbitMQ : 글로벌 트랜잭션 지원 / 클러스터,고가용성 지원 : 안정적인 메시지 전달 + 다양한 언어와 프로토콜 지원
	* 카프카 : 글로벌 트랜잭션 미지원 / 높은 성능

### 10.5.3 이벤트 저장소를 이용한 비동기 처리
* 로컬 이벤트 핸들러가 스토리지에 이벤트 저장한 뒤 실제 이벤트 핸들러에게 이벤트를 전달한다
	1. 포워더 방식 : 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행
		* 도메인과 이벤트 저장소가 동일한 DB
		-> 도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리된다.
		* 핸들러가 이벤트 처리 실패시 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러를 실행
	2. 이벤트 제공 API방식 : 핸들러가 API를 통해 저장소에서 이벤트를 읽어서 처리한다.
* 이벤트를 어디까지 처리했는지 추적하는 역할
	- 포워더 방식 : 포워터 책임
	- API방식 : 핸들러 책임

* 이벤트 저장소의 구현
	* EventEntry : 이벤트 저장소에 보관할 데이터. 
		* 구성요소 : 이벤트식별ID(id), 이벤트 타입(type), 데이터 타입(contentType), 데이터(payload), 이벤트 시간(timestamp)
	* EventStore 인터페이스 : 이벤트를 저장하고 조회하는 인터페이스
		* 이벤트 객체를 직렬화 해서 EventEntry의 payload에 저장한다.
		* 과거에 벌어진 사건이므로 데이터가 변경되지 않는다
			* 이벤트 추가, 조회 시능만 제공하고 이벤트 데이터 수정 기능은 제공하지 않는다.
			* 처리 여부는 저장....안하나?
	* jdbcEventStore : JDBC를 이용한 EvenetStore 구현 클래스
		* 책의 예제에서는 
			* auto_increment컬럼으로 주요키를 설정하여 insert시 주요키를 설정하지 않음.
			* limit을 이용해서 id순 정렬시 offset부터 limit개수만큼 조회하도록 구현됨.
	* EventApi : REST API를 이용해서 이벤트 목록을 제공하는 컨트롤러

* 이벤트 저장을 위한 이벤트 핸들러 구현
	* 로컬 이벤트 핸들러에서 이벤트를 전달받아 eventStore에 save한다.
	* Event 타입을 상속받은 이벤트 타입만 이벤트 저장소에 보관하기 위해 @EveneListener(Event.class)를 사용했다.
	
* REST API 구현
	* offset, limit 두 웹 요청 파라미터를 이용해서 EvenetStore#get을 실행하고 결과를 JSON으로 리턴
	* 이벤트 수정기능이 없으므로 REST API도 단순 조회기능만 존재
	* API 클라이언트의 동작
		1. 마지막에 처리안 데이터의 offset을 구해서 API를 실행한다.
		2. API에서 받은 이벤트를 처리한다.
		3. 마지막으로 처리된 데이터 인덱스를 offset으로 저장한다.
		4. 이벤트 처리 실패시, 실패한 이벤트부터 읽어와 이벤트를 재처리 한다. 
		5. API서버 장애시에도 주기적 재시도로 API서버 복구 후 이벤트를 처리한다.
		
* 포워더 구현
	* API방식의 클라이언트 구현과 유사하게 일정주기로 이벤트를 읽어서 이벤트 핸들러에 전달한다.
	* 클라이언트와 마찬가지로 마지막으로 전달한 Event offset을 기억해 두었다가 다음조회시점에 마지막 offset부터 이벤트를 가지고 온다.
	* 포워더의 동작
		1. 읽어와야할 offset을 구하고
		2. 이벤트 저장소에서 이벤트를 구해오고
		3. 이벤트의 존재여부를 검사하고 sendEvent()를 사용해 이벤트를 전송한다.
		4. sendEvent()에서 리턴받은 처리된 이벤트 개수를 offset에 업데이트한다.
	* @Scheduled 애너테이션을 사용해 주기적으로 실행 (스프링이 아닌경우 별도의 스케쥴링 프레임워크 사용
	* sendEvent() : eventSender.send()를 사용해 차례대로 발송하고 익셉션이 발생하면 전송에 성공한 이벤트 개수를 리턴

* 자동증가 칼럼 사용시 트랜잭션에 따라 데이터 조회에 오류가 발생할수 있으니 ID기준으로 데이터를 지연조회하는 방식을 사용한다.
		
* 이벤트 저장소에 처리여부 플래그를 추가하고 REST API요청시 마지막으로 처리된 이벤트를 반환하면 안되나?
	* 처리 결과 같은건 따로 저장....? 
	* -> 은 이벤트 핸들러 추가시 DB까지 변경해야되니까 각자 핸들러가 처리여부, 마지막 처리이벤트를 저장하고 있어야 하겠네요.

## 10.6 이벤트 적용 시 추가 고려 사항
1. 이벤트 소스를 EventEntry에 추가할 것인가?
	* 이벤트 발생주체에 대한 정보를 젖ㅇ하면 특정주체가 발생시킨 이벤트만 조회할 수 있다.
2. 포워더에서 전송 실패를 얼마나 허용할 것인가
	* 전송 실패가 계속되는 경우 해당 이벤트로 인해 나머지 이벤트가 전송불가
	* 따라서 구현시 재전송횟수 제한을 두어 나머지 이벤트가 전송될수 있도록 정책을 세워야 한다.
		* 처리 실패시 별도 실패 DB나 메시지큐에 저장하기도 한다. - 실패이유 분석/후처리 등에 사용
3. 이벤트 손실
	* 이벤트 저장소 사용시 이벤트 발생과 이벤트 저장이 하나의 트랜잭션
	* 하지만 로컬핸들러의 비동기 사용시 이벤트 처리에 실패 하면 이벤트가 유실된다.
4. 이벤트 순서
	* 이벤트 발생순서대로 전달해야 하는 경우 이벤트 저장소를 사용하는 것이 좋다.(저장소에서 발생순서대로 저장->제공)
	* 메시징 시스템은 구현 기술에 따라 발생순서와 전달순서가 달라질 수 있다.
5. 이벤트 재처리
	* 동일한 이벤트의 재처리시 이벤트를 어떻게 할 것인가? -  무시하기 /  멱등으로 처리하기 / 아묻따 재처리 하기
	> 멱등성 : 연산을 여러번 적용해도 결과가 달라지지 않는 성질 (ex : abs())
	> 이벤트 처리도 멱등성을 가지도록 핸들러를 구현하면 시스템장애시 중복발생이나 중복처리에 대한 부담을 줄여준다.
	
### 10.6.1 이벤트 처리와 DB트랜잭션 고려
* 이벤트 발생과 처리를 모두 동기로 처리 하는 경우 이벤트 처리까지 모두 성공하고 DB업데이트 실패하는 경우가 발생할 수 있다.
* 비동기로 처리할때도 DB업데이트를 끝내놓고 외부API처리 실패시의 이슈를 고려해야 한다.
* 따라서 동기/비동기 모두 이벤트 처리 실패와 트랜잭션 실패를 고려해야 하는데 두가지를 모두 고려하면 복잡해지므로 경우의 수를 줄여야 한다.
	* 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하면 경우의 수를 줄일 수 있다 
		* 스프링-@TransactionalEventListener
			- AFTER_COMMIT Phase를 사용하여 트랜잭션 커밋에 성공한 뒤 핸들러 메서드를 실행할 수 있다.
		* 이벤트 저장소로 DB 사용 - 이벤트 발생코드와 저장 처리를 한 트랜잭션으로 처리하여 트랜잭션 성공시에멘 이벤트가 DB에 저장되도록 한다.
	* 이제 이벤트 처리 실패만 고민하면 된다.
		* 이벤트 특성에 따라 재처리 방식을 결정한다.
