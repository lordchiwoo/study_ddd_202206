# Chapter 2. 아키텍처 개요

## 2.1 네 개의 영역
* Presentation/Application/Domain/Infrastructure - 전형적인 아키텍처 설계 구조
* Presentation : 사용자/서버의 요청을 Application 영역에 전달/Application영역의 처리결과를 다시 사용자/서버에 전달
  * 스프링 MVC가 대표적인 Presentation 영역
  * 웹애플리케이션의 Presentation 영역는 
    * HTTP Request를 Application이 요구하는 객체타입으로 변환해서 전달
    * 응용서비스가 리턴한 결과를 JSON형식으로 변환해서 HTTP Response
* Application(Application Service) : 사용자의 요청을 전달받아 시스템이 사용자에게 제공해야 할 기능을 구현
  * ex) 주문등록/주문취소/상품상세
  * 기능을 구현하기 위해 Domain 영역의 Domain Model을 사용  
  * 로직을 직접 수행하기 보다는 Domain Model에 로직 수행을 위임한다.
* Domain : Domain Model의 실질적인 구현
  * 도메인의 핵심 로직을 구현
  * ex) 주문 도메인에서 배송지 변경/결제 완료/주문 총액 계산 등의 핵심 로직이 도메인 모델에서 구현된다.
* Infrastructure : 구현 기술에 대한 것을 다룬다.
  * ex) RDBMS 연동 / 메시징큐에 메시지를 전송하거나 수신 / Mongo,Redis의 데이터 연동을 처리 / SMTP를 이용한 메일발송 기능 구현 / HTTP Client를 이용해 REST API를 호출하는등
  * 논리적인 개념 표현 보다는 실제 구현.
  * 도메인/응용/표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않고 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.
  * 응용영역에서
    * 데이터가 필요하면 인프라스트럭쳐 영역의 DB모듈을 사용해서 데이터를 Read
    * 외부에 메일을 발송해야 한다면 인프라스트럭쳐 영역의 SMTP연동모듈을 이용해서 메일을 발송
  
## 2.2 계층 구조 아키텍쳐
* Layered Architecture : 네 영역을 구성하는데 많이 사용하는 아키텍쳐
  * 의존 방향 : 표현 => 응용 => 도메인 => 인프라스트럭쳐
  * 도메인의 복잡도에 따라서 응용과 도메인을 분리하거나 합치는 경우도 있다.
  * 특성상 상위에서 하위로의 의존만 존재하고 하위계층은 상위계층에 의존하지 않는다.
    * 엄격하게 적용하자면 바로 하위의 계층에만 의존을 가져야 하지만 편의성을 위해 유연하게 적용하기도 한다. (응용 -> 도메인 -> 인프라 / 응용 -> 인프라)
  * 중요!(밑밥 for DIP) : 표현/응용/도메인이 상세한 구현기술을 다루는 인프라스트럭처 계층에 종속된다는 점.
	* 이때 응용/도메인 계층에서 실질적인 구현기술에 직접적인 의존을 하게되면 
	  1. 테스트가 힘들어지고
	  2. 구현방식의 변경이 어려워진다.
	* 그러면 어떻게? 정답은 DIP!

## 2.3 DIP
* 고수준 모듈 : 의미있는 단일 기능을 제공하는 모듈 - 여러 하위기능이 필요하다. (고객정보 구하기/룰 실행)
* 저수준 모듈 : 하위기능을 실제로 구현한 것 (RDBMS로 정보 읽어오기, Drools로 룰 적용하기)

* 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. But 구현 변경과 테스트가 어려워진다.

### DIP
* 저수준 모듈이 고수준 모듈에 의존하도록 한다.
* HOW? : 추상화된 인터페이스
* 고수준 모듈에서는 추상화된 인터페이스를 통해 저수준의 동작을 실행한다.
* 해당 인터페이스의 구현객체는 생성자를 통해 전달(주입?) 받는다.
* 실제 저수준 동작을 구현한 클래스는 해당 인터페이스를 상속받아 구현한다.
그림2.9는...좀 이상한데... 고수준하고 저수준이 바뀐거 아닌가?

* 고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 한다. 
* 반대로 저수준 모듈이 고수준 모듈에 의존하도록 하는 것이 Dependency Inversion Principle(DIP)
  * 구현 기술 교체 문제 해결 : 저수준 객체 생성 후 주입으로 고수준 모듈의 코드 수정없이 주입하는 객체를 변경하여 저수준 동작 추가 가능
  * 테스트 용이성 문제 해결 : 고수준 모듈의 동작 테스트를 위해 실제 저수준 모듈이 아니라 인터페이스를 사용한 대역객체를 사용하여 테스트를 진행할 수 있다.
    * jUnit - assertEquals/assertThrows
    * Mockito : 대역객체를 만드는데 자주 사용되는 프레임워크
	  * when().thenReturn() : ~~하면 --를 리턴 하는 Mock객체 생성
	  * when().thenThrow() / doThrow() : ~~하면 -- Exception을 throw 하는 Mock객체 생성 
	  * any() : Argument Matcher(무엇이 들어오든)
	  * when.then.then.then 의 메서드 체이닝을 통해 동일한 메서드 호출시 순서에 따라 동작을 조작할 수 있다
	  * verify() : Mock객체가 어떻게 사용되었는지 확인
	  
      * https://scshim.tistory.com/439

### 2.3.1 DIP 주의 사항
* 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함인데, 저수준 모듈에서 인터페이스를 추출하는 경우가 있다.
  * 도메인이 인프라영역에 의존하는 식으로 인터페이스를 추출해서는 안된다.
  * 하위기능을 추상화한 인터페이스는 고수준 모듈관점에서 도출해야만 한다.
    * ex) 고수준 모듈 입장에서 봤을 때, **할인금액을 구하기 위해** 룰엔진을 사용하는지 직접 연산하는지는 중요하지 않고, **규칙에 따라 할인 금액을 계산하는 것이 중요**
  * 즉 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치해야 한다.

### 2.3.2 DIP와 아키텍쳐
* 인프라스트럭쳐 계층이 가장 하단에 위치하는 계층형 구조와 달리 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.
  * 영향을 주지 않거나 최소화 하면서 구현기술을 변경할 수 있다.
** DIP를 항상 적용할 필요는 없다. 사용하는 구현기술에 따라 완벽한 DIP를 적용하기 보다는 구현 기술에 의존적인 코드를 도메인에 일부 포함하는 게 효과적일 때도 있다.

## 2.4 도메인 영역의 주요 구성요소
* 엔티티 : 고유식별자를 갖는 객체로 도메인의 고유개념을 표현 (데이터 + 기능)
* 밸류 : 고유식별자를 갖지 않는 객체로 개념적으로 하나인 값을 표현할 때 주로 사용. 엔티티 혹은 다른 밸류 타입의 속성으로도 사용
* **애그리거트** : 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은것. 
  * ex) 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 `주문` 애그리거트로 묶을 수 있다.
* 리포지터리 : 도메인 모델의 영속성을 처리
  * ex) DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공
* 도메인 서비스
  * 특정 엔티티에 속하지 않은 도메인 로직을 제공

### 2.4.1 엔티티와 밸류
* DB 엔티티 != 도메인모델 엔티티
* 도메인모델의 엔티티는 
  * 도메인 기능을 함께 제공하는 데이터+기능 객체
  * 두개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현가능
  * 관계형 DB는 Value타입을 제대로 표현하기가 힘들다.(..FK를 사용해서 가능하...지 않은가? 또다른 엔티티일뿐?)
  * 밸류는 불변으로 구현을 권장 == 엔티티의 밸류타입 데이터 변경할 때는 객체 자체를 완전히 교체한다는 것을 의미
  
### 2.4.2 애그리거트
* 도메인이 커질수록 도메인모델도 커지면서 엔티티와 밸류가 많아지고 모델은 점점 더 복잡해짐.
* 개발자가 전체 구조가 아닌 부분에 집중하는 상황이 발생
* 개별요소에 초점을 맞추면서 큰 관점에서 모델을 이해하고 관리할 수 없는 상황이 빠질 수 있다.
* 지도의 소축척 처럼 도메인 모델도 상위수준에서 모델을 파악할 수 있어야 함.

* 애그리거트
  * 애그리거트는 관련된 객체를 하나로 묶은 군집 (여러 하위모델을 하나로 묶어서 상위개념으로 표현)
  * 애그리거트를 사용하여 관련객체들을 묶어서 객체 군집 단위로 모델을 파악하면 큰 틀에서 도메인 모델을 관리할 수 있다.

  * 루트엔티티 : 군집에 속한 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야할 기능을 제공
  * 애그리거트를 사용하는 코드
    * 애그리거트 루트가 제공하는 기능을 실행
	* 애그리거트를 통해 **간접**적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근
		* 내부 구현을 숨겨서 **애그리거트 단위로 구현을 캡슐화**
	* 루트를 통하지 않고 내부 엔티티나 밸류를 수정할 수 없도록 하여 항상 애그리거트의 도메인로직을 따르도록 한다.
  * 구현시 고려해야 할 것 : 3장에 기술 (구성/트랜잭션 범위/선택 기술에 따른 제약)

### 2.4.3 리포지터리
* 물리적 저장소(RDBMS/NoSQL/로컬파일 등)를 위한 도메인 모델
* 요구사항에서 도출되는 엔티티나 밸류와 달리 구현을 위한 도메인 모델이다.

* 애그리거트 단위로 도메인 객체를 저장/조회
* 도메인 모델 사용코드는 리포지터리를 통해 도메인 객체를 구해서 그 객체의 기능을 실행
* 도메인 모델 관점에서
  * 리포지터리는 도메인 객체를 영속화하는 데 필요한 기능을 추상화 한 것으로 **고수준 모듈(도메인 영역)**
  * 기반 기술을 이용해 리포지터리를 구현한 클래스는 **저수준 모듈(인프라스트럭쳐 영역)**

* 응용서비스가
  * 필요한 도메인 객체를 구하거나 저장할 때 리포지터리 사용
  * 트랜잭션 관리할 때 실제 처리는 리포지터리 구현 기술의 영향을 받음
  
* 기본적으로 save, findById / 필요에 따라 delete, counts
  
## 2.5 요청 처리 흐름
![요청 처리 흐름](https://github.com/lordchiwoo/study_ddd_202206/raw/main/book_contents/fig2.20.jpg)
* 표현영역(Controller) : 요청데이터를 응용서비스에 맞게 변환하고 응용서비스의 기능을 실행
* 응용서비스(App Service) : 도메인 모델을 이용해서 기능을 구현
  * 리포지터리에서 기능 구현에 필요한 도메인 객체를 가지고 와서 실행
  * 신규 도메인 객체를 생성해서 리포지터리에 저장
  * 두개 이상의 도메인 객체를 사용해서 구현하기도 함
* 응용서비스의 결과를 컨트롤러에서 받아서 다시 사용자에게 응답.

  * 도메인의 상태를 변경하는 기능을 제공하는 경우 
    * 응용서비스는 변경 상태를 올바르게 물리저장소에 반영할 수 있도록 트랜젝션을 관리 해야한다.
	* 스프링의 경우 @Transactional 어노테이션을 이용해서 트랜잭션을 처리
	
## 2.6 인프라스트럭처 개요
* 지원 영역 : 표현/영역/영역(즉 모두)
* ex) 도메인 객체의 영속성처리/트랜잭션/SMTP,REST 클라이언트
* 표현 영역은 항상 인프라스트럭쳐 영역과 쌍을 이룬다.(DIP ㄴㄴ? - 직접적으로 데이터를 주고받고 변환하는 부분이라서?)
* 도메인/응용 영역 : 인프라스트럭처의 기능을 직접 사용하기보다 각 영역에 인터페이스를 정의하고 해당 인터페이스를 인프라 영역에서 구현하라(DIP)
  * 절대적인 것은 아님. 구현의 편리함과 DIP의 다른 장점간의 TradeOff를 고민하여 DIP의 장점을 해치지 않는 범위에서 의존을 사용
    * 완전히 갖지 않도록 하려면 구현이 너무 복잡하거나 어려워 질수 있다.
    * ex) 트랜잭션의 경우 어노테이션 한줄로 가능한 것
      * 의존 제거를 위해 복잡한 설정을 사용하거나 증가하는 개발 시간을 감수하고 얻을 수 있는 이점이 없음

## 2.7 모듈 구성
* 도메인 아키텍쳐와 패키징 - 정답은 없으나 영역별로 모듈이 위치할 패키지를 구성 (ui/app/domain/infra)

![도메인 아키텍쳐와 패키징](https://github.com/lordchiwoo/study_ddd_202206/raw/main/book_contents/fig2.21.jpg)

* 도메인이 크면 하위도메인으로 나누고 각 도메인마다 별도 패키지를 구성(catalog/order/member)

![하위도메인](https://github.com/lordchiwoo/study_ddd_202206/raw/main/book_contents/fig2.22.jpg)
* domain모듈 내부에서는 애그리거트를 기준으로 다시 패키지를 구성(product/category)

![domain모듈 내부](https://github.com/lordchiwoo/study_ddd_202206/raw/main/book_contents/fig2.23.jpg)

* 애그리거트/모델/리포지터리는 같은 패키지에 위치시킨다.
* 도메인이 복잡하면 도메인 모델과 서비스를 별도 패키지에 위치시킬 수 있다.
  * com.myshop.order.domain.`order` : 애그리거트
  * com.myshop.order.domain.`service` : 도메인 서비스
* 응용서비스도 복잡한 경우 도메인 별로 패키지를 구분할 수 있다.
  * com.myshop.catalog.application.`product`
  * com.myshop.catalog.application.`category`
